# API Contract: RAG Chatbot Frontend Integration

## Base Information
- **Base URL**: `/api/v1` (as defined in backend)
- **Content-Type**: `application/json`
- **Authentication**: None required for public-facing chatbot
- **CORS**: Enabled for frontend domain

## Endpoints

### 1. Query Agent
**Path**: `POST /ask`
**Description**: Submit a question to the RAG agent and receive an answer based on book content

#### Request
```json
{
  "query": "string (required) - The question to ask",
  "session_id": "string (optional) - Session identifier for maintaining context",
  "user_id": "string (optional) - User identifier"
}
```

#### Response (Success - 200 OK)
```json
{
  "response_id": "string - Unique identifier for the response",
  "answer": "string - The answer generated by the agent",
  "sources": [
    {
      "chunk_id": "string - Unique identifier for the retrieved chunk",
      "content": "string - Content of the retrieved chunk",
      "url": "string - Source URL of the content",
      "position": "integer - Position in the original document",
      "relevance_score": "float - Similarity score"
    }
  ],
  "query_id": "string - Reference to the original query",
  "timestamp": "string - ISO 8601 formatted timestamp",
  "confidence_score": "float - Estimated confidence in the answer"
}
```

#### Response (Error - 400 Bad Request)
```json
{
  "error": "string - Error message describing the issue",
  "error_code": "string - Code identifying the type of error"
}
```

## Frontend Component Interface

### Chat Message Format
The frontend will receive and send messages in the following format:

```json
{
  "id": "string - Unique message identifier",
  "content": "string - The message text content",
  "sender": "string - Either 'user' or 'agent'",
  "timestamp": "string - ISO 8601 formatted timestamp",
  "sources": [
    {
      "chunk_id": "string - Source chunk identifier",
      "url": "string - Source URL",
      "content": "string - First 100 characters of the source content"
    }
  ]
}
```

### Loading State Format
The frontend will manage loading states using:

```json
{
  "isLoading": "boolean - Whether the system is processing a request",
  "progress": "number (optional) - Progress percentage (0-100)",
  "message": "string (optional) - Status message to display"
}
```

### Error State Format
The frontend will handle errors with:

```json
{
  "hasError": "boolean - Whether an error occurred",
  "errorMessage": "string - User-friendly error message",
  "errorType": "string - Type of error ('network', 'validation', 'server', 'timeout')",
  "retryAvailable": "boolean - Whether the action can be retried"
}
```

## WebSocket (Optional Future Enhancement)
**Path**: `ws://[host]/ws/chat`
**Description**: For real-time communication (not in initial scope)

#### Message Format
```json
{
  "type": "string - Message type ('message', 'typing', 'error', 'connection')",
  "data": "object - Message data payload",
  "timestamp": "string - ISO 8601 formatted timestamp"
}
```

## Common Headers

### Request Headers
- `Content-Type`: `application/json`
- `X-Request-ID`: Unique identifier for the request (optional)
- `X-Session-ID`: Session identifier for tracking conversation context (optional)

### Response Headers
- `X-Response-Time`: Processing time in milliseconds
- `X-Request-ID`: Echoed request ID if provided

## Error Responses

All endpoints may return the following standard error responses:

### 400 Bad Request
```json
{
  "error": "string - Error message describing the validation issue",
  "error_code": "string - Code identifying the validation error",
  "details": "object - Specific validation errors"
}
```

### 429 Rate Limit Exceeded
```json
{
  "error": "Rate limit exceeded",
  "retry_after": "number - Seconds to wait before retrying",
  "error_code": "RATE_LIMIT_EXCEEDED"
}
```

### 500 Internal Server Error
```json
{
  "error": "string - Error message describing the server issue",
  "error_code": "string - Code identifying the type of error"
}
```

## Rate Limiting

Requests will be rate-limited based on the following criteria:
- Per IP address: 60 requests per minute
- Per session: 100 requests per minute